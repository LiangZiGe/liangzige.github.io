---
layout: post
title: 符号位扩展纠结
date: 2017-02-28 10:11:00
categories: C语言
tags: 笔记
---

[Bit Twiddling Hacks](http://graphics.stanford.edu/~seander/bithacks.html)刚开始看就纠结了一个问题，如下：

    Compute the sign of an integer
    
    int v;      // we want to find the sign of v
    int sign;   // the result goes here 
    
    // CHAR_BIT is the number of bits per byte (normally 8).
    sign = -(v < 0);  // if v < 0 then -1, else 0. 
    // or, to avoid branching on CPUs with flag registers (IA32):
    sign = -(int)((unsigned int)((int)v) >> (sizeof(int) * CHAR_BIT - 1));
    // or, for one less instruction (but not portable):
    sign = v >> (sizeof(int) * CHAR_BIT - 1); 
    
为什么`but not portable(但不可移植)`呢？有了`(unsigned int)((int)v)`转换就可以移植了？于是找到[符号扩展](http://www.dbgtech.net/windbghelp/hh/debugger/r13_syntax_fab581c5-bc83-4c7a-80b0-828deb1ffb83.xml.htm)译文(原文：https://msdn.microsoft.com/zh-cn/library/ff556892(v=vs.85).aspx )，方便看直接拷贝过来。
    
    符号扩展
    
    当一个 32 位整数为负数时，它的最高位等于一。强制转换为 64 位数值时，有两种可能性：最高位全设为零，保留无符号整数和十六进制数值，或者最高位全设为一，保留带符号数值。后面一种被称为符号扩展。
    
    在 MASM 表达式中、C++ 表达式中以及显示数值时，调试器遵循不同的规则实现符号扩展。
    
    MASM 表达式中的符号扩展
    
    在某种情况下，MASM 表达式求解器会把数值自动进行符号扩展。符号扩展只影响 0x80000000 和 0xFFFFFFFF 之间的数，包括 － 换句话说，就是最高位等于 1 的32 位数。
    
    所以，当调试器把 0x12345678 转换为 64 位数时总是保持 0x00000000`12345678。另一方面，当 0x890ABCDE 被转换为 64 位值时可能保持 0x00000000`890ABCDE 或者可能被扩展为 0xFFFFFFFF`890ABCDE。
    
    0x80000000 和 0xFFFFFFFF 之间的数是否会被符号扩展，根据下面的标准：
    
    用户模式下常数永远不会被符号扩展。内核模式下，除非在低字节前包含重音符号( ` )，否则常数将被符号扩展。例如，内核模式下十六进制数值 EEAA1122 和 00000000EEAA1122 将被符号扩展，但 00000000`EEAA1122 和 0`EEAA1122 不会。
    两种模式下 32 位寄存器都将被符号扩展。
    伪寄存器总是作为 64 位值存储。所以计算时不会有符号扩展的问题。当伪寄存器是一个带符号值时，表达式根据C++标准进行求值。
    表达式中的单个数值和寄存器可能会被符号扩展，但表达式计算被扩展期间不会有其它的计算操作。你可以使用下面的语法给一个数值或者寄存器的最高位加上掩码操作。
    ( 0x0`FFFFFFFF & expression )
    
    C++ 表达式中的符号扩展
    
    调试器使用下面的规则计算一个 C++ 表达式：
    
    寄存器和伪寄存器永远不会被符号扩展
    所有其它数值都被以 C++的方式按类型转换为正确的值。
    符号扩展数和 64 位数的显示
    
    不同于 32 位和 16 位寄存器，在调试器内部所有数值都被当做 64 位值存储。然而，当数值满足一定条件时，在命令输出中它将被当做 32 位数显示。
    
    调试器显示数值的算法如下：
    
    如果某个数的高 32 位都为零 (换句话说，如果该数处在 0x00000000`00000000 到 0x00000000`FFFFFFFF 范围)，那么它被当做 32 位数显示。
    如果某个数的高 32 位都为一，而且低 32 位中的最高位也为一 (换句话说，如果该数处在 0xFFFFFFFF`80000000 到 0xFFFFFFFF`FFFFFFFF 范围)，那么调试器假定它是一个被符号扩展的 32 位数，当做 32 位数显示。
    如果不是上面两种情况 (换句话说，如果该数处在 0x00000001`00000000 到 0xFFFFFFFF`7FFFFFFF 范围)那么它被当做 64 位数显示。
    这些规则会产生一个结果，当一个数被显示为 0x80000000 到 0xFFFFFFFF 之间的 32 位数值时，你不能确定它的最高 32 位全部是一还是零。要区别这两种情况你需要在这个数上执行一个额外的计算操作（例如屏蔽最高的一位或多位然后显示结果）。

仔细阅读发现由于符号扩展的情况繁多，可能导致结果不一致，所以存在符号运算时最好操作无符号类型，方便移植。